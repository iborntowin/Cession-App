name: CI/CD Pipelinename: CI/CD Pipeline



on:on:

  push:  push:

    branches: [ main, master ]    branches: [ main, master ]

  pull_request:  pull_request:

    branches: [ main, master ]    branches: [ main, master ]

  release:  release:

    types: [ published ]    types: [ published ]

  workflow_dispatch:  workflow_dispatch:

    inputs:    inputs:

      version_type:      version_type:

        description: 'Version increment type'        description: 'Version increment type'

        required: false        required: false

        default: 'patch'        default: 'patch'

        type: choice        type: choice

        options:        options:

          - patch          - patch

          - minor          - minor

          - major          - major

      create_release:      create_release:

        description: 'Create a new release after successful build'        description: 'Create a new release after successful build'

        required: false        required: false

        default: 'false'        default: 'false'

        type: choice        type: choice

        options:        options:

          - 'true'          - 'true'

          - 'false'          - 'false'



permissions:permissions:

  contents: write  contents: write

  pull-requests: write  pull-requests: write



jobs:jobs:

  test-backend:  test-backend:

    runs-on: ubuntu-latest    runs-on: ubuntu-latest

    steps:    steps:

    - uses: actions/checkout@v4    - uses: actions/checkout@v4



    - name: Set up JDK 17    - name: Set up JDK 17

      uses: actions/setup-java@v4      uses: actions/setup-java@v4

      with:      with:

        java-version: '17'        java-version: '17'

        distribution: 'temurin'        distribution: 'temurin'

        cache: maven        cache: maven



    - name: Cache Maven dependencies    - name: Cache Maven dependencies

      uses: actions/cache@v4      uses: actions/cache@v4

      with:      with:

        path: ~/.m2        path: ~/.m2

        key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}        key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}

        restore-keys: ${{ runner.os }}-m2        restore-keys: ${{ runner.os }}-m2



    - name: Build with Maven    - name: Build with Maven

      run: cd backend && mvn clean compile      run: cd backend && mvn clean compile



    - name: Run backend tests    - name: Run backend tests

      run: cd backend && mvn test      run: cd backend && mvn test



    - name: Upload test results    - name: Upload test results

      uses: actions/upload-artifact@v4      uses: actions/upload-artifact@v4

      if: always()      if: always()

      with:      with:

        name: backend-test-results        name: backend-test-results

        path: backend/target/surefire-reports/        path: backend/target/surefire-reports/



  test-frontend:  test-frontend:

    runs-on: ubuntu-latest    runs-on: ubuntu-latest

    steps:    steps:

    - uses: actions/checkout@v4    - uses: actions/checkout@v4



    - name: Set up Node.js    - name: Set up Node.js

      uses: actions/setup-node@v4      uses: actions/setup-node@v4

      with:      with:

        node-version: '18'        node-version: '18'

        cache: 'npm'        cache: 'npm'

        cache-dependency-path: frontend/package-lock.json        cache-dependency-path: frontend/package-lock.json



    - name: Install frontend dependencies    - name: Install frontend dependencies

      run: cd frontend && npm ci      run: cd frontend && npm ci



    - name: Run frontend tests    - name: Run frontend tests

      run: cd frontend && npm run test:coverage      run: cd frontend && npm run test:coverage



    - name: Upload test results    - name: Upload test results

      uses: actions/upload-artifact@v4      uses: actions/upload-artifact@v4

      if: always()      if: always()

      with:      with:

        name: frontend-test-results        name: frontend-test-results

        path: frontend/coverage/        path: frontend/coverage/



  bump-version:  bump-version:

    needs: [test-backend, test-frontend]    needs: [test-backend, test-frontend]

    runs-on: ubuntu-latest    runs-on: ubuntu-latest

    if: github.event_name == 'workflow_dispatch' && github.event.inputs.create_release == 'true'    if: github.event_name == 'workflow_dispatch' && github.event.inputs.create_release == 'true'

    outputs:    outputs:

      new_version: ${{ steps.version.outputs.new_version }}      new_version: ${{ steps.version.outputs.new_version }}

    steps:    steps:

    - uses: actions/checkout@v4    - uses: actions/checkout@v4

      with:      with:

        fetch-depth: 0        fetch-depth: 0



    - name: Setup Node.js    - name: Setup Node.js

      uses: actions/setup-node@v4      uses: actions/setup-node@v4

      with:      with:

        node-version: '18'        node-version: '18'



    - name: Install frontend dependencies    - name: Setup Java

      run: cd frontend && npm ci      uses: actions/setup-java@v4

      with:

    - name: Bump version        java-version: '17'

      id: version        distribution: 'temurin'

      run: |        cache: maven

        cd frontend

    - name: Install frontend dependencies

        CURRENT_VERSION=$(node -p "require('./package.json').version")      run: cd frontend && npm ci

        echo "Current version: $CURRENT_VERSION"

    - name: Bump version

        npm version ${{ github.event.inputs.version_type }} --no-git-tag-version      id: version

      run: |

        NEW_VERSION=$(node -p "require('./package.json').version")        cd frontend

        echo "New version: $NEW_VERSION"

        echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT        # Show current version

        CURRENT_VERSION=$(node -p "require('./package.json').version")

        cd src-tauri        echo "üì¶ Current version: $CURRENT_VERSION"

        jq ".version = \"$NEW_VERSION\"" tauri.conf.json > temp.json && mv temp.json tauri.conf.json

        # Bump version

    - name: Commit version bump        echo "‚¨ÜÔ∏è  Bumping ${{ github.event.inputs.version_type }} version..."

      run: |        npm version ${{ github.event.inputs.version_type }} --no-git-tag-version

        git config --local user.email "action@github.com"

        git config --local user.name "GitHub Action"        NEW_VERSION=$(node -p "require('./package.json').version")

        echo "‚ú® New version: $NEW_VERSION"

        if git diff --quiet && git diff --staged --quiet; then        echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT

          echo "No changes to commit"

        else        # Update tauri.conf.json

          git add .        echo "üîß Updating Tauri configuration..."

          git commit -m "Bump version to ${{ steps.version.outputs.new_version }}"        cd src-tauri

        fi        jq ".version = \"$NEW_VERSION\"" tauri.conf.json > temp.json && mv temp.json tauri.conf.json



    - name: Push changes    - name: Commit version bump

      run: |      run: |

        if git log --oneline origin/master..HEAD | grep -q .; then        echo "üíæ Checking for version changes..."

          git push        git config --local user.email "action@github.com"

        fi        git config --local user.name "GitHub Action"



    - name: Create tag        # Check if there are any changes to commit

      run: |        if git diff --quiet && git diff --staged --quiet; then

        TAG_NAME="v${{ steps.version.outputs.new_version }}"          echo "‚ÑπÔ∏è  No changes to commit (version already exists)"

        else

        if git tag -l | grep -q "^$TAG_NAME$"; then          git add .

          echo "Tag $TAG_NAME already exists"          git commit -m "‚¨ÜÔ∏è Bump version to ${{ steps.version.outputs.new_version }}"

        else          echo "‚úÖ Changes committed"

          git tag "$TAG_NAME"        fi

        fi

    - name: Push changes

        git push origin "$TAG_NAME"      run: |

        echo "üöÄ Checking for changes to push..."

  build-tauri:        # Check if there are commits to push

    needs: [test-backend, test-frontend]        if git log --oneline origin/master..HEAD | grep -q .; then

    if: always() && (needs.test-backend.result == 'success' || needs.test-backend.result == 'skipped') && (needs.test-frontend.result == 'success' || needs.test-frontend.result == 'skipped')          git push

    runs-on: windows-latest          echo "‚úÖ Changes pushed successfully"

    steps:        else

    - name: Checkout repository          echo "‚ÑπÔ∏è  No new commits to push"

      uses: actions/checkout@v4        fi



    - name: Setup Node.js    - name: Create tag

      uses: actions/setup-node@v4      run: |

      with:        TAG_NAME="v${{ steps.version.outputs.new_version }}"

        node-version: '18'        echo "üè∑Ô∏è  Checking/creating git tag $TAG_NAME..."

        cache: 'npm'

        cache-dependency-path: frontend/package-lock.json        # Check if tag already exists

        if git tag -l | grep -q "^$TAG_NAME$"; then

    - name: Setup Java          echo "‚úÖ Tag $TAG_NAME already exists, using existing tag"

      uses: actions/setup-java@v4        else

      with:          echo "üìù Creating new tag $TAG_NAME"

        java-version: '17'          git tag "$TAG_NAME"

        distribution: 'temurin'        fi

        cache: maven

        # Push the tag (this will work whether it was just created or already existed)

    - name: Rust setup        git push origin "$TAG_NAME"

      uses: dtolnay/rust-toolchain@stable        echo "‚úÖ Tag $TAG_NAME pushed successfully"



    - name: Rust cache  build-tauri:

      uses: swatinem/rust-cache@v2    needs: [test-backend, test-frontend]

      with:    if: always() && (needs.test-backend.result == 'success' || needs.test-backend.result == 'skipped') && (needs.test-frontend.result == 'success' || needs.test-frontend.result == 'skipped')

        workspaces: './frontend/src-tauri -> target'    strategy:

      fail-fast: false

    - name: Build backend      matrix:

      run: |        include:

        cd backend          - platform: 'windows-latest'

        mvn clean package -DskipTests            args: '--target x86_64-pc-windows-msvc'

    runs-on: ${{ matrix.platform }}

    - name: Copy backend JAR    steps:

      run: |    - name: Checkout repository

        mkdir -p frontend/src-tauri/backend      uses: actions/checkout@v4

        cp backend/target/cession-app-backend-0.0.1-SNAPSHOT.jar frontend/src-tauri/backend/

    - name: Setup Node.js

    - name: Install frontend dependencies      uses: actions/setup-node@v4

      run: cd frontend && npm ci      with:

        node-version: '18'

    - name: Build frontend        cache: 'npm'

      run: cd frontend && npm run build:production        cache-dependency-path: frontend/package-lock.json



    - name: Build Tauri app    - name: Setup Java

      uses: tauri-apps/tauri-action@v0      uses: actions/setup-java@v4

      env:      with:

        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}        java-version: '17'

      with:        distribution: 'temurin'

        projectPath: './frontend/src-tauri'        cache: maven

        args: '--target x86_64-pc-windows-msvc'

    - name: Rust setup

    - name: Upload artifacts      uses: dtolnay/rust-toolchain@stable

      uses: actions/upload-artifact@v4

      with:    - name: Rust cache

        name: windows-installer      uses: swatinem/rust-cache@v2

        path: |      with:

          frontend/src-tauri/target/x86_64-pc-windows-msvc/release/bundle/msi/*.msi        workspaces: './frontend/src-tauri -> target'

          frontend/src-tauri/target/x86_64-pc-windows-msvc/release/bundle/nsis/*.exe

        if-no-files-found: error    - name: Build backend

      run: |

  release:        cd backend

    needs: [build-tauri, bump-version]        mvn clean package -DskipTests

    runs-on: ubuntu-latest

    if: github.event_name == 'workflow_dispatch' && github.event.inputs.create_release == 'true'    - name: Copy backend JAR

    env:      run: |

      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}        mkdir -p frontend/src-tauri/backend

    steps:        cp backend/target/cession-app-backend-0.0.1-SNAPSHOT.jar frontend/src-tauri/backend/

    - name: Checkout repository

      uses: actions/checkout@v4    - name: Install frontend dependencies

      run: cd frontend && npm ci

    - name: Download artifacts

      uses: actions/download-artifact@v4    - name: Build frontend

      with:      run: cd frontend && npm run build:production

        name: windows-installer

        path: ./artifacts    - name: Build Tauri app

      uses: tauri-apps/tauri-action@v0

    - name: Display artifacts      env:

      run: |        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

        echo "Build artifacts:"      with:

        find ./artifacts -type f        projectPath: './frontend/src-tauri'

        args: ${{ matrix.args }}

    - name: Create latest.json

      run: |    - name: Upload artifacts

        VERSION="${{ needs.bump-version.outputs.new_version }}"      uses: actions/upload-artifact@v4

              with:

        cat > latest.json << EOF        name: artifacts-${{ matrix.platform }}-${{ matrix.args }}

        {        path: ./frontend/src-tauri/target/x86_64-pc-windows-msvc/release/bundle/**

          "version": "$VERSION",        if-no-files-found: error

          "notes": "Release $VERSION - Automated build from GitHub Actions",

          "pub_date": "$(date -u +'%Y-%m-%dT%H:%M:%SZ')",  release:

          "platforms": {    needs: build-tauri

            "windows-x86_64": {    runs-on: ubuntu-latest

              "signature": "",    if: github.event_name == 'release' || (github.event_name == 'workflow_dispatch' && github.event.inputs.create_release == 'true')

              "url": "https://github.com/${{ github.repository }}/releases/download/v$VERSION/cession-app-installer.exe"    steps:

            }    - name: Checkout repository

          }      uses: actions/checkout@v4

        }

        EOF    - name: Download all artifacts

      run: |

    - name: Create GitHub Release        echo "üì• Downloading build artifacts..."

      run: |        # Download all artifacts

        VERSION="${{ needs.bump-version.outputs.new_version }}"        mkdir -p ./artifacts

        TAG_NAME="v$VERSION"

    - name: Download all artifacts

        if gh release view "$TAG_NAME" >/dev/null 2>&1; then      uses: actions/download-artifact@v4

          echo "Release $TAG_NAME already exists"      with:

        else        path: ./artifacts

          gh release create "$TAG_NAME" \

            --title "Release $VERSION" \    - name: Display structure of downloaded files

            --notes "Automated release $VERSION from GitHub Actions CI/CD pipeline" \      run: |

            --draft=false \        echo "üìÇ Build artifacts downloaded:"

            --prerelease=false        find ./artifacts -type f -name "*.exe" -o -name "*.msi" | head -10

        fi

    - name: Create latest.json for auto-updates

    - name: Upload release assets      run: |

      run: |        if [ "${{ github.event_name }}" = "release" ]; then

        VERSION="${{ needs.bump-version.outputs.new_version }}"          VERSION=${GITHUB_REF#refs/tags/v}

        TAG_NAME="v$VERSION"        elif [ "${{ github.event_name }}" = "workflow_dispatch" ]; then

          VERSION=${{ needs.bump-version.outputs.new_version }}

        gh release upload "$TAG_NAME" ./latest.json --clobber        fi

        echo "üîñ Creating latest.json for version: $VERSION"

        MSI_FILE=$(find ./artifacts -name "*.msi" | head -1)

        if [ -f "$MSI_FILE" ]; then        # Create latest.json for Tauri auto-updates

          gh release upload "$TAG_NAME" "$MSI_FILE" --clobber        cat > latest.json << EOF

        fi        {

          "version": "$VERSION",

        EXE_FILE=$(find ./artifacts -name "*.exe" | head -1)          "notes": "Release $VERSION - Automated build",

        if [ -f "$EXE_FILE" ]; then          "pub_date": "$(date -u +'%Y-%m-%dT%H:%M:%SZ')",

          gh release upload "$TAG_NAME" "$EXE_FILE" --clobber          "platforms": {

        fi            "windows-x86_64": {
              "signature": "",
              "url": "https://github.com/${{ github.repository }}/releases/download/v$VERSION/Cession.Management.App_$VERSION_x64-setup.exe"
            }
          }
        }
        EOF
        echo "‚úÖ latest.json created"

    - name: Create GitHub Release
      if: github.event_name == 'workflow_dispatch'
      run: |
        TAG_NAME="v${{ needs.bump-version.outputs.new_version }}"
        echo "üì¶ Checking if release exists for $TAG_NAME..."

        # Check if release already exists
        if gh release view "$TAG_NAME" >/dev/null 2>&1; then
          echo "‚úÖ Release for $TAG_NAME already exists, skipping creation"
        else
          echo "üöÄ Creating new release for $TAG_NAME..."

          # Create release notes
          RELEASE_NOTES="## üöÄ Release ${{ needs.bump-version.outputs.new_version }}

This release was automatically created via GitHub Actions CI/CD pipeline.

### üìã Details
- **Version**: ${{ needs.bump-version.outputs.new_version }}
- **Type**: ${{ github.event.inputs.version_type }} update
- **Build**: Automated Windows build
- **Date**: \$(date -u +'%Y-%m-%d %H:%M:%S UTC')

### üì¶ Downloads
- Windows Installer (.exe)
- Windows MSI (.msi)
- Auto-update manifest (latest.json)"

          gh release create "$TAG_NAME" \
            --title "Release ${{ needs.bump-version.outputs.new_version }}" \
            --notes "$RELEASE_NOTES" \
            --draft=false \
            --prerelease=false
          echo "‚úÖ Release created successfully"
        fi
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Upload Release Assets
      if: github.event_name == 'workflow_dispatch'
      run: |
        VERSION=${{ needs.bump-version.outputs.new_version }}
        TAG_NAME="v$VERSION"
        echo "üì§ Uploading release assets for version $VERSION..."

        # Upload latest.json (use --clobber to overwrite if exists)
        echo "‚¨ÜÔ∏è  Uploading latest.json..."
        gh release upload "$TAG_NAME" ./latest.json --clobber

        # Find and upload MSI file
        MSI_FILE=$(find ./artifacts -name "*.msi" | head -1)
        if [ -f "$MSI_FILE" ]; then
          echo "‚¨ÜÔ∏è  Uploading MSI installer: $(basename "$MSI_FILE")"
          gh release upload "$TAG_NAME" "$MSI_FILE" --clobber
        else
          echo "‚ö†Ô∏è  MSI file not found"
        fi

        # Find and upload EXE file
        EXE_FILE=$(find ./artifacts -name "*.exe" | head -1)
        if [ -f "$EXE_FILE" ]; then
          echo "‚¨ÜÔ∏è  Uploading EXE installer: $(basename "$EXE_FILE")"
          gh release upload "$TAG_NAME" "$EXE_FILE" --clobber
        else
          echo "‚ö†Ô∏è  EXE file not found"
        fi

        echo "‚úÖ All assets uploaded successfully!"

    - name: Upload latest.json (GitHub Release)
      if: github.event_name == 'release'
      uses: actions/upload-release-asset@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        upload_url: ${{ github.event.release.upload_url }}
        asset_path: ./latest.json
        asset_name: latest.json
        asset_content_type: application/json

    - name: Upload Windows MSI (GitHub Release)
      if: github.event_name == 'release'
      uses: actions/upload-release-asset@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        upload_url: ${{ github.event.release.upload_url }}
        asset_path: ./artifacts/artifacts-windows-latest---target-x86_64-pc-windows-msvc/msi/Cession.Management.App_${VERSION}_x64_en-US.msi
        asset_name: Cession.Management.App_${VERSION}_x64_en-US.msi
        asset_content_type: application/x-msi

    - name: Upload Windows NSIS (GitHub Release)
      if: github.event_name == 'release'
      uses: actions/upload-release-asset@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        upload_url: ${{ github.event.release.upload_url }}
        asset_path: ./artifacts/artifacts-windows-latest---target-x86_64-pc-windows-msvc/nsis/Cession.Management.App_${VERSION}_x64-setup.exe
        asset_name: Cession.Management.App_${VERSION}_x64-setup.exe
        asset_content_type: application/x-msdownload
