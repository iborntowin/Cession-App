/**
 * Auto-Update Manager for Cession Management App
 * Comprehensive error logging and progress tracking
 * Version: 2.0 - Enhanced Diagnostics
 */

import { check } from '@tauri-apps/plugin-updater';
import { relaunch } from '@tauri-apps/plugin-process';
import { getVersion } from '@tauri-apps/api/app';
import { showAlert } from './stores';

// Detailed error logger
function logError(context, error, additionalInfo = {}) {
  const errorLog = {
    timestamp: new Date().toISOString(),
    context,
    errorType: error?.constructor?.name || 'Unknown',
    errorMessage: error?.message || String(error),
    errorStack: error?.stack || 'No stack trace',
    additionalInfo,
    userAgent: typeof navigator !== 'undefined' ? navigator.userAgent : 'N/A',
    platform: typeof window !== 'undefined' && window.__TAURI__ ? 'Tauri' : 'Browser'
  };
  
  console.error('ğŸ”´ ERROR LOG:', JSON.stringify(errorLog, null, 2));
  return errorLog;
}

// Detailed status logger
function logStatus(status, message, data = {}) {
  const statusLog = {
    timestamp: new Date().toISOString(),
    status,
    message,
    data
  };
  
  console.log(`ğŸ“Š STATUS [${status}]:`, message, data);
  return statusLog;
}

/**
 * Enhanced update checker with progress callback support
 * @param {Function} onProgress - Callback function for progress updates
 * @param {Function} onStatus - Callback function for status updates
 * @returns {Promise<Object>} Update result with status
 */
export async function checkForUpdatesEnhanced(onProgress = null, onStatus = null) {
  const updateStatus = (status, details = {}) => {
    console.log(`ğŸ“Š Update Status: ${status}`, details);
    if (onStatus) onStatus(status, details);
  };

  const updateProgress = (downloaded, total, percent) => {
    console.log(`ğŸ“¥ Download Progress: ${percent}% (${formatBytes(downloaded)} / ${formatBytes(total)})`);
    if (onProgress) onProgress({ downloaded, total, percent });
  };

  try {
    updateStatus('checking', { message: 'Connecting to update server...' });
    console.log('ğŸ” ============================================');
    console.log('ğŸ” CHECKING FOR UPDATES');
    console.log('ğŸ” ============================================');
    console.log('ğŸ“¡ Endpoint: https://github.com/iborntowin/Cession-App/releases/latest/download/latest.json');
    
    // Get current version first
    const currentVersion = await getCurrentVersion();
    console.log('ğŸ“‹ Current installed version:', currentVersion);
    
    // Check for updates with longer timeout
    const timeoutPromise = new Promise((_, reject) => 
      setTimeout(() => reject(new Error('Update check timed out after 30 seconds')), 30000)
    );
    
    const update = await Promise.race([check(), timeoutPromise]);
    
    console.log('ğŸ“¦ ============================================');
    console.log('ğŸ“¦ UPDATE CHECK RESPONSE');
    console.log('ğŸ“¦ Raw response:', JSON.stringify(update, null, 2));
    console.log('ğŸ“¦ Response type:', typeof update);
    console.log('ğŸ“¦ Response is null:', update === null);
    console.log('ğŸ“¦ Response is undefined:', update === undefined);
    if (update) {
      console.log('ğŸ“¦ update.available:', update.available);
      console.log('ğŸ“¦ update.version:', update.version);
      console.log('ğŸ“¦ update.currentVersion:', update.currentVersion);
    }
    console.log('ğŸ“¦ ============================================');
    
    // When update is null, it means we're already up to date
    if (!update) {
      console.log('âœ… ============================================');
      console.log('âœ… NO UPDATE NEEDED (null response)');
      console.log(`âœ… Current version: ${currentVersion}`);
      console.log('âœ… You are already on the latest version');
      console.log('âœ… ============================================');
      
      updateStatus('up-to-date', { 
        currentVersion,
        message: `You're on the latest version (${currentVersion})` 
      });
      
      return { 
        success: true, 
        available: false, 
        currentVersion,
        message: 'Already up to date' 
      };
    }
    
    if (update.available) {
      const newVersion = update.version;
      const releaseNotes = update.body || 'New features and improvements included.';
      
      console.log('âœ¨ ============================================');
      console.log('âœ¨ UPDATE AVAILABLE!');
      console.log(`âœ¨ Current: ${currentVersion}`);
      console.log(`âœ¨ New: ${newVersion}`);
      console.log(`âœ¨ Notes: ${releaseNotes}`);
      console.log('âœ¨ Update object type:', typeof update);
      console.log('âœ¨ Update object keys:', Object.keys(update || {}));
      console.log('âœ¨ Update object:', JSON.stringify(update, null, 2));
      console.log('âœ¨ ============================================');
      
      updateStatus('available', {
        currentVersion,
        newVersion,
        releaseNotes,
        update: update, // Include the full update object
        message: `Update ${newVersion} is available!`
      });
      
      return {
        success: true,
        available: true,
        currentVersion,
        newVersion,
        releaseNotes,
        update: update // Make sure update object is returned
      };
    } else {
      console.log('âœ… ============================================');
      console.log('âœ… NO UPDATE NEEDED');
      console.log(`âœ… Current version: ${currentVersion}`);
      console.log(`âœ… Latest version: ${update.version || 'unknown'}`);
      console.log('âœ… You are already on the latest version');
      console.log('âœ… ============================================');
      
      updateStatus('up-to-date', { 
        currentVersion,
        latestVersion: update.version,
        message: `You're on the latest version (${currentVersion})` 
      });
      
      return { 
        success: true, 
        available: false, 
        currentVersion,
        latestVersion: update.version,
        message: 'Already up to date' 
      };
    }
  } catch (error) {
    console.error('âŒ Update check failed:', error);
    console.error('Error type:', error.constructor.name);
    console.error('Error message:', error.message);
    console.error('Error stack:', error.stack);
    
    updateStatus('error', { 
      error: error.message,
      errorType: error.constructor.name,
      message: `Update check failed: ${error.message}`
    });
    
    return { 
      success: false, 
      error: error.message,
      errorType: error.constructor.name,
      fullError: error
    };
  }
}

/**
 * Download and install an update
 * @param {Object} updateObject - The update object from check()
 * @param {Function} onProgress - Progress callback
 * @param {Function} onStatus - Status callback
 * @returns {Promise<Object>} Installation result
 */
export async function downloadAndInstallUpdate(updateObject, onProgress = null, onStatus = null) {
  const updateStatus = (status, details = {}) => {
    console.log(`ğŸ“Š Install Status: ${status}`, details);
    if (onStatus) onStatus(status, details);
  };

  const updateProgress = (downloaded, total, percent) => {
    console.log(`ğŸ“¥ Download: ${percent}% (${formatBytes(downloaded)} / ${formatBytes(total)})`);
    if (onProgress) onProgress({ downloaded, total, percent });
  };

  try {
    console.log('ğŸ“¥ ============================================');
    console.log('ğŸ“¥ STARTING DOWNLOAD & INSTALL');
    console.log('ğŸ“¥ ============================================');
    updateStatus('downloading', { message: 'Starting download...' });
    
    let lastPercent = 0;
    
    // Download and install with progress tracking
    await updateObject.downloadAndInstall((event) => {
      // Log EVERY event with full details for debugging
      console.log('ï¿½ ============================================');
      console.log('ğŸ“¦ RAW EVENT RECEIVED');
      console.log('ğŸ“¦ Event object:', JSON.stringify(event, null, 2));
      console.log('ğŸ“¦ Event type:', typeof event);
      console.log('ğŸ“¦ Event keys:', Object.keys(event || {}));
      if (event.data) {
        console.log('ğŸ“¦ Event data keys:', Object.keys(event.data || {}));
        console.log('ğŸ“¦ Event data:', JSON.stringify(event.data, null, 2));
      }
      console.log('ğŸ“¦ ============================================');
      
      try {
        if (event.event === 'Started') {
          const contentLength = event.data?.contentLength || 0;
          updateStatus('downloading', { 
            message: 'Download started',
            contentLength,
            contentLengthMB: (contentLength / (1024 * 1024)).toFixed(2)
          });
          console.log(`ï¿½ DOWNLOAD STARTED`);
          console.log(`ğŸš€ Total size: ${formatBytes(contentLength)} (${contentLength} bytes)`);
          updateProgress(0, contentLength, 0);
        } 
        else if (event.event === 'Progress') {
          // Try multiple possible property names for Tauri v2 compatibility
          // In Tauri v2, the event structure might be: { event: 'Progress', data: { chunkLength, contentLength } }
          let downloaded = 0;
          let total = 1;
          
          // Try different property paths
          if (event.data) {
            downloaded = event.data.chunkLength || event.data.downloaded || event.data.current || 0;
            total = event.data.contentLength || event.data.total || event.data.size || 1;
          } else if (event.chunkLength !== undefined) {
            // Sometimes properties are at top level
            downloaded = event.chunkLength || 0;
            total = event.contentLength || 1;
          }
          
          console.log(`ğŸ“Š Progress event received:`, {
            downloaded,
            total,
            eventData: event.data,
            eventKeys: Object.keys(event)
          });
          
          if (downloaded === 0 && total <= 1) {
            console.warn('âš ï¸ WARNING: Invalid progress values detected!');
            console.warn('âš ï¸ downloaded:', downloaded, 'total:', total);
            console.warn('âš ï¸ Full event:', JSON.stringify(event, null, 2));
            // Don't update progress with invalid values
            return;
          }
          
          const percent = total > 0 ? Math.round((downloaded / total) * 100) : 0;
          
          // Log every 5% to avoid spam but track progress
          if (percent >= lastPercent + 5 || percent === 100 || percent === 0) {
            console.log(`ğŸ“¥ Download ${percent}% - ${formatBytes(downloaded)} / ${formatBytes(total)}`);
            updateStatus('downloading', {
              message: `Downloading: ${percent}%`,
              downloaded,
              total,
              percent,
              downloadedMB: (downloaded / (1024 * 1024)).toFixed(2),
              totalMB: (total / (1024 * 1024)).toFixed(2)
            });
            lastPercent = percent;
          }
          
          updateProgress(downloaded, total, percent);
        }
        else if (event.event === 'Finished') {
          console.log('âœ… DOWNLOAD COMPLETE');
          updateStatus('installing', { message: 'Installing update...' });
          console.log('ğŸ”§ Starting installation phase...');
          updateProgress(1, 1, 100);
        }
        else {
          console.log(`â“ UNKNOWN EVENT TYPE: "${event.event}"`);
          console.log('â“ Full event:', event);
        }
      } catch (eventError) {
        console.error('ğŸ’¥ Error in event handler:', eventError);
        console.error('ğŸ’¥ Stack:', eventError.stack);
      }
    });
    
    console.log('ğŸ”§ ============================================');
    console.log('ğŸ”§ INSTALLATION COMPLETE');
    console.log('ğŸ”§ ============================================');
    updateStatus('installed', { message: 'Update installed successfully!' });
    console.log('âœ… Update installed successfully!');
    console.log('ğŸ”„ Preparing to restart application in 2 seconds...');
    
    // Wait a moment before relaunch
    await new Promise(resolve => setTimeout(resolve, 2000));
    
    updateStatus('restarting', { message: 'Restarting application...' });
    console.log('ğŸ”„ Executing relaunch...');
    
    try {
      await relaunch();
      return { success: true };
    } catch (relaunchError) {
      console.error('ğŸ’¥ Relaunch failed:', relaunchError);
      updateStatus('relaunch-error', {
        message: 'Failed to restart. Please restart manually.',
        error: relaunchError.message
      });
      return { success: false, error: 'Relaunch failed: ' + relaunchError.message };
    }
    
  } catch (error) {
    console.error('ğŸ’¥ ============================================');
    console.error('ğŸ’¥ INSTALLATION FAILED');
    console.error('ğŸ’¥ ============================================');
    console.error('ğŸ’¥ Error type:', error.constructor.name);
    console.error('ğŸ’¥ Error message:', error.message);
    console.error('ğŸ’¥ Error stack:', error.stack);
    
    updateStatus('install-error', { 
      error: error.message,
      errorType: error.constructor.name,
      message: `Installation failed: ${error.message}`
    });
    
    return { 
      success: false, 
      error: error.message,
      errorType: error.constructor.name 
    };
  }
}

/**
 * Legacy function for backward compatibility
 * Check for available updates and prompt user to install
 * @returns {Promise<boolean>} True if update was installed, false otherwise
 */
export async function checkForUpdates(silent = false) {
  try {
    console.log('ğŸ” Checking for updates (legacy mode)...');
    
    const update = await check();
    
    if (update?.available) {
      console.log(`âœ¨ Update available: ${update.version}`);
      console.log(`ğŸ“ Current version: ${update.currentVersion}`);
      console.log(`ğŸ“‹ Release notes: ${update.body}`);
      
      if (!silent) {
        showAlert(`Update ${update.version} available!`, 'info');
      }
      
      return true;
    } else {
      if (!silent) {
        console.log('âœ… No updates available');
        showAlert('You are using the latest version! ğŸ‰', 'success');
      }
      return false;
    }
  } catch (error) {
    console.error('âŒ Update check failed:', error);
    if (!silent) {
      showAlert(`Update check failed: ${error.message}`, 'error');
    }
    return false;
  }
}

/**
 * Format bytes to human-readable format
 * @param {number} bytes - Number of bytes
 * @returns {string} Formatted string (e.g., "1.5 MB")
 */
function formatBytes(bytes) {
  if (bytes === 0) return '0 B';
  const k = 1024;
  const sizes = ['B', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}

/**
 * Get current app version
 * @returns {Promise<string>} Current version
 */
export async function getCurrentVersion() {
  try {
    return await getVersion();
  } catch (error) {
    console.error('Failed to get app version:', error);
    return 'Unknown';
  }
}

/**
 * Set up automatic update checking
 * Checks on startup and every 24 hours
 */
export function setupAutoUpdateCheck() {
  console.log('âš™ï¸ Setting up automatic update checking...');
  
  // Check for updates 30 seconds after startup (silent)
  setTimeout(() => {
    console.log('ğŸ• Running scheduled update check (startup)...');
    checkForUpdates(true).catch(err => 
      console.error('Startup update check failed:', err)
    );
  }, 30000);
  
  // Check for updates every 24 hours (silent)
  setInterval(() => {
    console.log('ğŸ• Running scheduled update check (24h interval)...');
    checkForUpdates(true).catch(err => 
      console.error('Scheduled update check failed:', err)
    );
  }, 24 * 60 * 60 * 1000);
  
  console.log('âœ… Automatic update checking enabled');
}
